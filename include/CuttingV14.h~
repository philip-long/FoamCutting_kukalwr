
#include <ViSPConfiguration.h>
//fri include
#include <FastResearchInterface.h>
#include <Console.h>
#include <errno.h>
#include <string.h>
#include <OSAbstraction.h>
#include <FastResearchInterfaceTest.h>
#include <TypeIRML.h>

#include <visp/vpVideoWriter.h>
// ViSP includes
#include <visp/vpConfig.h>
#include <visp/vpImage.h>
#include <visp/vpPose.h>
#include <visp/vpMath.h>
#include <visp/vpHomogeneousMatrix.h>
#include <visp/vpMbEdgeTracker.h>
#include <visp/vpTrackingException.h>
#include <visp/vpDisplayX.h>
#include <visp/vpDisplayGDI.h>
#include <visp/vpDisplayGTK.h>
#include <visp/vpDisplayD3D.h>
#include <visp/vp1394TwoGrabber.h>
#include <visp/vpImageTools.h>
#include <visp/vpMatrix.h>

#include <visp/vpServo.h> //visual servoing task
#include<visp/vpMomentObject.h>
#include<visp/vpMomentCentered.h>
#include<visp/vpMomentCInvariant.h>
#include<visp/vpMomentCommon.h>


// Use to compute the interaction matrix
#include <visp/vpFeatureMomentGravityCenter.h>
#include <visp/vpFeatureMomentGravityCenterNormalized.h>
#include<visp/vpFeatureMomentAlpha.h>
#include<visp/vpFeatureMomentAreaNormalized.h>
#include<visp/vpFeatureMomentCInvariant.h>
#include <visp/vpFeatureMomentCommon.h> //init the feature database using the information about moment dependencies



#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <cv.h>
#include <highgui.h>
#include <fstream>

#ifndef PI
#define PI			3.1415926535897932384626433832795
#endif

#ifndef RAD
#define RAD(A)	((A) * PI / 180.0 )
#endif

#ifndef DEG
#define DEG(A)	((A) * 180.0 / PI )
#endif

#define NUMBER_OF_POSE			12
#define NUMBER_OF_JOINTS		7
using namespace std;




/*-------------------------------------------------------------------------------------------------------

FRI Variables

-------------------------------------------------------------------------------------------------------*/

float CommandedJointVelocity[7]; // desired joint velocity
float MeasuredJointValues[7]; // Measure joint values
float CommandedJointValues[7];// Desired joint values
float cycletime;// cycle time
float Measuredforce[6]; // measured force
float MeasuredPose[12];// measured tool 
float timecounter=0.0; // actual time spent
float **FriJaco;  //to store the measured Jacobian from KUKA
FriJaco = new float* [6];
for(int i=0;i<6;i++)
FriJaco[i] = new float[7];




/*-------------------------------------------------------------------------------------------------------

ViSP VARIABLES

-------------------------------------------------------------------------------------------------------*/

// Create the variables requried for the camera
bool reset = true; // Enable bus reset during construction (default)
vp1394TwoGrabber g(reset);
if (reset) 
{
vpTime::wait(50); // Wait 1000 ms
}
g.setCamera(0);
g.setVideoMode(vp1394TwoGrabber::vpVIDEO_MODE_640x480_MONO8);
g.setFramerate(vp1394TwoGrabber::vpFRAMERATE_30);
vpCameraParameters camdistored;// Camera Parameters updated 5-Nov-2013
camdistored.initPersProjWithDistortion(1267.612068,1268.174369, 320.344917, 236.6983837,-0.1277547589,0.129434146);

// Create a ViSP gray image
vpImage<unsigned char> I;
vpImage<unsigned char> Idesired;
IplImage* displayedImage = 0;



vpColVector cVcam(6),tVcam(6);


int TrackBars[7];

float JointSpeedGain=0.0;
// Init filter

IplImage* displayedImage2 = 0;
TrackBars[0]=100;TrackBars[1]=0; // Thresholding
TrackBars[2]=0;TrackBars[3]=0;
TrackBars[4]=400;TrackBars[5]=300;
TrackBars[6]=100;
cvNamedWindow("Controls", 0);
cvCreateTrackbar( "Binarise Thres 1", "Controls", &TrackBars[0], 255, NULL );
cvCreateTrackbar( "Unused", "Controls", &TrackBars[1], 100, NULL );// Maximum blob size, these are functions of the knife
cvCreateTrackbar( "Subarea i", "Controls", &TrackBars[2], 480, NULL );// Manimum blob size
cvCreateTrackbar( "Subarea j", "Controls", &TrackBars[3], 640, NULL );// Aspect ratio best is 1
cvCreateTrackbar( "Unused","Controls", &TrackBars[4], 480, NULL );
cvCreateTrackbar( "Unsed nj","Controls", &TrackBars[5], 640, NULL );
cvCreateTrackbar( "Cutting Speed","Controls", &TrackBars[6], 100, NULL );

unsigned char Threshold;



//***************************VISP subsection declarations***************************

vpColVector bVt(6),V(6),tV(6),bOmegat(3),qdot(6),qinit(7),qt(7),Vcam(6);
vpMatrix J(6,7); // Jacobian Matrix
vpRotationMatrix bRt,tRb,tRcam;
vpHomogeneousMatrix bMtinit,bMtd,bMt,tMb;
vpColVector camPim(4),bPim(4);


// ViSP moment variables

vpMomentObject obj(6); // Create a source moment object with 6 as maximum order
vpMomentObject dst(6); // Create a source moment object with 6 as maximum order
vpImageIo::readPGM(Idesired,"./pics/Image0");
printf("\n Image OK");
obj.setType(vpMomentObject::DENSE_FULL_OBJECT);
dst.setType(vpMomentObject::DENSE_FULL_OBJECT); // The object is defined by a countour polygon
dst.fromImage(Idesired,100,camdistored);

double Zdesired=0.28057;
vpMomentCommon mdb_cur(vpMomentCommon::getSurface(dst),vpMomentCommon::getMu3(dst),vpMomentCommon::getAlpha(dst),Zdesired); //Init classic features
vpFeatureMomentCommon fmdb_cur(mdb_cur);
vpMomentCommon mdb_dst(vpMomentCommon::getSurface(dst),vpMomentCommon::getMu3(dst),vpMomentCommon::getAlpha(dst),Zdesired); //Init classic features
vpFeatureMomentCommon fmdb_dst(mdb_dst);

mdb_cur.updateAll(dst);
fmdb_cur.updateAll(0.,0.,1.);
mdb_dst.updateAll(dst);
fmdb_dst.updateAll(0.,0.,1.);

// Task definition

printf("\n \n Task Definition \n \n");
vpServo task;
task.setServo(vpServo::EYEINHAND_CAMERA);
task.setInteractionMatrixType(vpServo::CURRENT);
task.setLambda(0.02);
task.addFeature(fmdb_cur.getFeatureGravityNormalized(),fmdb_dst.getFeatureGravityNormalized());
task.addFeature(fmdb_cur.getFeatureAn(),fmdb_dst.getFeatureAn());
//task.addFeature(fmdb_cur.getFeatureArea(),fmdb_dst.getFeatureArea());
task.addFeature(fmdb_cur.getFeatureCInvariant(),fmdb_dst.getFeatureCInvariant(),vpFeatureMomentCInvariant::selectPx() | vpFeatureMomentCInvariant::selectPy());
task.addFeature(fmdb_cur.getFeatureAlpha(),fmdb_dst.getFeatureAlpha());

vpColVector err_features;
vpMatrix Linteraction;
vpColVector s_current;
vpColVector s_desired;
vpColVector cVc;



g.acquire(I);
vpDisplay *d2;
vpImage<unsigned char> I2(I.getHeight(), I.getWidth(),255);
vpImageTools::binarise(I2, (unsigned char)100, (unsigned char)255, (unsigned char) 255, (unsigned char)0, (unsigned char)0);
d2 = new vpDisplayX;
d2->init(I2);
vpDisplay::setWindowPosition(I2, 100, 100);// Specify the window location
vpDisplay::display(I2);
vpDisplay::flush(I2);
vpDisplay::setTitle(I2, "Processed Image");


vpDisplay *ddesired;
ddesired = new vpDisplayX;
ddesired->init(Idesired);
vpDisplay::setWindowPosition(Idesired, 100, 100);// Specify the window location
vpDisplay::display(Idesired);
vpDisplay::flush(Idesired);
vpDisplay::setTitle(Idesired, "Desired Image");



//==========================================================================================//



/*-------------------------------------------------------------------------------------------------------

INPUT VARIABLES

-------------------------------------------------------------------------------------------------------*/
vpHomogeneousMatrix camMt,tMcam,eMf,eMt,bMtsafe,bMtsafe2,bMtv;
float temp_x[11]; // A temporary variable 
GETHomogeneousMatrix(tMcam,"./ConstantMatrices/tMc");  //Camera to Tool frame
GETHomogeneousMatrix(eMf,"./ConstantMatrices/eMf");  //End effector to force sensor frame
GETHomogeneousMatrix(eMt,"./ConstantMatrices/eMt");  //End effector to tool frame

printf("\n tMcam=\n");printfM(tMcam);
camMt=tMcam.inverse();
tMcam.extract(tRcam);
printf("camMt=\n");printfM(tMcam);


/*-------------------------------------------------------------------------------------------------------

FORCE VARIABLES

-------------------------------------------------------------------------------------------------------*/

FILE * pFile;pFile=fopen("./CuttingV14/IdentifiedForceParameter","rb");
float MovingAverageForce[6];
vpMatrix ForceBuffer(5,6);
vpColVector x(11); // Idenitifed mass parameters of force sensor
vpColVector	ResolvedForce(6);


fscanf(pFile,"%f;%f;%f;%f;%f;%f;%f;%f;%f;%f;%f",&temp_x[0],&temp_x[1],&temp_x[2],&temp_x[3],&temp_x[4],&temp_x[5],&temp_x[6],&temp_x[7],&temp_x[8],&temp_x[9],&temp_x[10]);
	

for (int i=0;i<11;i++)
{
x[i]=temp_x[i];
}


printf("\n X=%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f",x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[9]);


/*-------------------------------------------------------------------------------------------------------

OUTPUT VARIABLES

-------------------------------------------------------------------------------------------------------*/
  

ofstream OutputS;     OutputS.open("./CuttingV14/Results/S",std::ios::out | std::ios::trunc );
ofstream OutputSd;     OutputSd.open("./CuttingV14/Results/Sd",std::ios::out | std::ios::trunc );
ofstream Outputuv;     Outputuv.open("./CuttingV14/Results/Uv",std::ios::out | std::ios::trunc );
ofstream OutputDS;    OutputDS.open("./CuttingV14/Results/Sdelta",std::ios::out | std::ios::trunc );
ofstream OutputCurveParameters;     OutputCurveParameters.open("./CuttingV14/Results/Curve",std::ios::out | std::ios::trunc );
ofstream OutputMeasuredbMt;      OutputMeasuredbMt.open("./CuttingV14/Results/bMt",std::ios::out | std::ios::trunc  );
ofstream OutputCmdbV;      OutputCmdbV.open("./CuttingV14/Results/OutputCmdbV",std::ios::out | std::ios::trunc  );
ofstream OutputCmdtV;      OutputCmdtV.open("./CuttingV14/Results/OutputCmdtV",std::ios::out | std::ios::trunc  );
ofstream OutputMeasuredForce;	OutputMeasuredForce.open("./CuttingV14/Results/MeasuredForce",std::ios::out | std::ios::trunc );
ofstream OutputResolvedForce;	OutputResolvedForce.open("./CuttingV14/Results/ResolvedForce",std::ios::out | std::ios::trunc );
ofstream OutputMovingAverageForce; OutputMovingAverageForce.open("./CuttingV14/Results/MovingAverageForce",std::ios::out | std::ios::trunc );

//*************************************END OF DECLARATIONS**********************************************************************










/*************************************************************************************************************

Initialising the robot

*************************************************************************************************************/

FRI->GetMeasuredJointPositions(MeasuredJointValues);
FRI->GetMeasuredCartPose(MeasuredPose);
FRICartPose2vpHomogeneousMatrix(MeasuredPose,bMtinit);


printf("\n bMtinit=\n");printfM(bMtinit);

// Eventually both of these will be supplied by camera
float MaterialHeight=.450; 
//float MaterialLength=-0.445;
//float MaterialHeight=.150; 
float MaterialLength=.350;
float CutDepth=.09; 
printf("cycletime=%f\n",cycletime);
